<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mind Map</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  /* ── Themes ── */
  :root {
    --bg:             #1e1e1e;
    --text:           #c8c8c8;
    --placeholder:    #555;
    --border:         #3a3a3a;
    --btn-bg:         #1e1e1e;
    --drop-bg:        #2e2e2e;
    --sel-bg:         #3a3a3a;
    --overlay-bg:     rgba(30,30,30,0.92);
    --progress-track: #333;
    --del-color:      #444;
  }
  @media (prefers-color-scheme: light) {
    :root {
      --bg:             #ffffff;
      --text:           #1e1e1e;
      --placeholder:    #bbb;
      --border:         #d0ceca;
      --btn-bg:         #ffffff;
      --drop-bg:        #e8e6e0;
      --sel-bg:         #d0ceca;
      --overlay-bg:     rgba(255,255,255,0.92);
      --progress-track: #ddd;
      --del-color:      #ccc;
    }
  }

  ::selection { background: var(--sel-bg); color: var(--text); }

  body {
    background: var(--bg);
    font-family: 'JetBrains Mono', monospace;
    overflow: hidden;
    width: 100vw; height: 100vh;
    cursor: default;
    user-select: none;
    transition: background 0.2s;
  }

  #canvas-wrap {
    width: 100%; height: 100%;
    position: relative;
    overflow: hidden;
  }

  #map-container {
    position: absolute;
    top: 0; left: 0;
    transform-origin: 0 0;
    z-index: 2;
  }

  #svg-layer {
    position: absolute;
    top: 0; left: 0;
    width: 9999px; height: 9999px;
    pointer-events: none;
    z-index: 1;
    overflow: visible;
  }

  .node-el {
    position: absolute;
    display: flex;
    align-items: center;
    height: 22px;
    white-space: nowrap;
    transition: top 0.15s ease, left 0.15s ease, opacity 0.15s ease;
  }

  .node-el.node-entering { opacity: 0; }
  .node-el.node-visible  { opacity: 1; }

  .node-label {
    font-size: 13px;
    font-weight: 400;
    color: var(--text);
    letter-spacing: 0.01em;
    cursor: pointer;
    white-space: nowrap;
    padding: 1px 4px;
    border-radius: 2px;
    transition: background 0.1s;
  }
  .node-label.placeholder { color: var(--placeholder); cursor: text; }
  .node-label.placeholder::after {
    content: '';
    animation: dots 1.5s infinite;
  }
  @keyframes dots {
    0%   { content: ''; }
    25%  { content: '.'; }
    50%  { content: '..'; }
    75%  { content: '...'; }
    100% { content: ''; }
  }

  .node-el.is-editing .node-label { display: none; }
  @keyframes blink-border { 0%,100% { opacity: 1; } 50% { opacity: 0; } }
  .node-input {
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    font-weight: 400;
    color: var(--text);
    background: transparent;
    border: none;
    outline: none;
    padding: 1px 4px;
    border-radius: 2px;
    min-width: 50px;
    width: 80px;
    letter-spacing: 0.01em;
    user-select: text;
    caret-color: var(--text);
  }
  .node-el.is-editing {
    position: relative;
  }
  .node-el.is-editing::after {
    content: '';
    position: absolute;
    bottom: 2px;
    left: 4px;
    width: var(--understroke-w, 9px);
    height: 1px;
    background: var(--text);
    animation: blink-border 1s step-start infinite;
  }


  .node-label.selected { background: rgba(200,200,200,0.15); }
  body.light .node-label.selected { background: rgba(0,0,0,0.08); }
  #drag-ghost {
    position: fixed;
    pointer-events: none;
    z-index: 999;
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    color: var(--text);
    background: var(--btn-bg);
    border: 1px solid var(--border);
    padding: 2px 8px;
    border-radius: 2px;
    display: none;
    white-space: nowrap;
    box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  }

  .node-el.drop-target .node-label { background: var(--drop-bg); }

  .map-line {
    stroke: var(--text);
    stroke-width: 1px;
    fill: none;
    stroke-linecap: square;
    stroke-linejoin: miter;
  }
  .map-line.drop-line {
    stroke: var(--text);
    stroke-width: 1px;
  }

  #controls {
    position: fixed;
    bottom: 24px; right: 24px;
    display: flex; gap: 6px;
    z-index: 100;
    align-items: center;
  }

  .ctrl-btn {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: var(--text);
    background: var(--btn-bg);
    border: 1px solid var(--border);
    padding: 5px 12px;
    cursor: pointer;
    border-radius: 2px;
    letter-spacing: 0.02em;
    transition: border-color 0.1s, color 0.1s, opacity 0.15s;
    height: 28px;
  }
  .ctrl-btn:hover { border-color: var(--text); color: var(--text); }
  .ctrl-btn:disabled { opacity: 0.3; cursor: default; pointer-events: none; }

  #btn-start-over { position: relative; }
  #start-over-tip {
    position: absolute;
    bottom: calc(100% + 8px);
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    padding: 4px 8px;
    white-space: nowrap;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s ease;
    z-index: 200;
  }
  #start-over-tip.visible { opacity: 1; }

  #btn-start-over { color: #c87; border-color: #5a3a3a; }
  #btn-start-over:hover { border-color: #d44; color: #d44; }

  #hint {
    position: fixed;
    bottom: 24px; left: 24px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text);
    z-index: 100;
    pointer-events: none;
    display: grid;
    grid-template-columns: repeat(3, auto);
    gap: 2px 24px;
    opacity: 0.6;
  }

  #export-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: var(--overlay-bg);
    z-index: 200;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: var(--placeholder);
    letter-spacing: 0.04em;
  }
  #export-overlay.visible { display: flex; }
  #export-progress-wrap {
    width: 180px; height: 2px;
    background: var(--progress-track); border-radius: 1px; overflow: hidden;
  }
  #export-progress-bar {
    height: 100%; width: 0%;
    background: #c8c8c8;
    transition: width 0.2s ease;
    border-radius: 1px;
  }

  /* ── Help modal ── */
  #help-overlay {
    display: none;
    position: fixed;
    inset: 0;
    z-index: 300;
  }
  #help-overlay.visible { display: block; }
  #help-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0);
    transition: background 0.4s ease;
  }
  #help-overlay.visible #help-backdrop {
    background: rgba(0,0,0,0.25);
  }
  #help-modal {
    position: absolute;
    top: 0; right: 0; bottom: 0;
    width: 340px;
    background: var(--bg);
    border-left: 1px solid var(--border);
    padding: 40px 32px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: var(--text);
    overflow-y: auto;
    transform: translateX(100%);
    transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
  }
  #help-overlay.visible #help-modal {
    transform: translateX(0);
  }
  #help-modal h2 {
    font-size: 10px;
    font-weight: 500;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    margin-bottom: 28px;
    opacity: 0.4;
  }
  .help-section { margin-bottom: 24px; }
  .help-section-title {
    font-size: 10px;
    opacity: 0.35;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: 10px;
  }
  .help-row {
    display: flex;
    justify-content: space-between;
    gap: 16px;
    padding: 4px 0;
  }
  .help-key {
    opacity: 0.45;
    white-space: nowrap;
    flex-shrink: 0;
  }
  .help-desc { opacity: 0.8; text-align: right; }
  #help-close {
    position: absolute;
    top: 16px; right: 20px;
    background: none; border: none;
    color: var(--text); opacity: 0.3;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px; cursor: pointer;
    padding: 4px 8px;
    transition: opacity 0.15s;
  }
  #help-close:hover { opacity: 0.8; }
</style>
</head>
<body>

<div id="canvas-wrap">
  <div id="map-container">
    <svg id="svg-layer"></svg>
  </div>
</div>

<div id="drag-ghost"></div>

<div id="controls">
  <button class="ctrl-btn" onclick="exportSVG()">svg</button>
  <button class="ctrl-btn" onclick="exportRaster('png')">png</button>
  <button class="ctrl-btn" onclick="exportRaster('jpeg')">jpeg</button>
  <button class="ctrl-btn" onclick="resetZoom()">reset view</button>
  <button class="ctrl-btn" onclick="zoomOut()">−</button>
  <button class="ctrl-btn" onclick="zoomIn()">+</button>
  <button class="ctrl-btn" id="btn-start-over" onclick="startOver(event)">start over<span id="start-over-tip">hold ctrl</span></button>
  <button class="ctrl-btn" onclick="toggleHelp()">?</button>
</div>

<div id="help-overlay">
  <div id="help-backdrop" onclick="toggleHelp()"></div>
  <div id="help-modal">
    <button id="help-close" onclick="toggleHelp()">esc</button>
    <h2>how to use</h2>

    <div class="help-section">
      <div class="help-section-title">navigation</div>
      <div class="help-row"><span class="help-key">↑ / ↓</span><span class="help-desc">move between nodes at the same depth</span></div>
      <div class="help-row"><span class="help-key">← / →</span><span class="help-desc">go to parent / first child</span></div>
    </div>

    <div class="help-section">
      <div class="help-section-title">editing</div>
      <div class="help-row"><span class="help-key">enter</span><span class="help-desc">open edit on selected node</span></div>
      <div class="help-row"><span class="help-key">enter (in edit)</span><span class="help-desc">confirm and create sibling</span></div>
      <div class="help-row"><span class="help-key">tab (in edit)</span><span class="help-desc">confirm and create child</span></div>
      <div class="help-row"><span class="help-key">escape (in edit)</span><span class="help-desc">cancel and revert changes</span></div>
      <div class="help-row"><span class="help-key">double click</span><span class="help-desc">open edit on any node</span></div>
      <div class="help-row"><span class="help-key">del / backspace</span><span class="help-desc">delete selected node</span></div>
    </div>

    <div class="help-section">
      <div class="help-section-title">drag & drop</div>
      <div class="help-row"><span class="help-key">drag</span><span class="help-desc">reorder node within same parent</span></div>
      <div class="help-row"><span class="help-key">ctrl + drag</span><span class="help-desc">move node to a different parent</span></div>
    </div>

    <div class="help-section">
      <div class="help-section-title">history & view</div>
      <div class="help-row"><span class="help-key">ctrl + z</span><span class="help-desc">undo</span></div>
      <div class="help-row"><span class="help-key">ctrl + y</span><span class="help-desc">redo</span></div>
      <div class="help-row"><span class="help-key">scroll</span><span class="help-desc">zoom in / out</span></div>
      <div class="help-row"><span class="help-key">click + drag (canvas)</span><span class="help-desc">pan the view</span></div>
      <div class="help-row"><span class="help-key">reset view</span><span class="help-desc">fit entire tree to window</span></div>
      <div class="help-row"><span class="help-key">ctrl + start over</span><span class="help-desc">clear the entire map</span></div>
    </div>

    <div class="help-section">
      <div class="help-section-title">export</div>
      <div class="help-row"><span class="help-key">svg</span><span class="help-desc">export as vector graphic</span></div>
      <div class="help-row"><span class="help-key">png</span><span class="help-desc">export as image with transparent background</span></div>
      <div class="help-row"><span class="help-key">jpeg</span><span class="help-desc">export as compressed image</span></div>
    </div>
  </div>
</div>

<div id="hint">
  <div>tab — child</div>
  <div>enter — edit / sibling</div>
  <div>ctrl + z / y — undo / redo</div>
  <div>↑↓ — navigate</div>
  <div>← → — parent / child</div>
  <div>drag — reorder &nbsp; ctrl + drag — reparent</div>
</div>

<div id="export-overlay">
  <span id="export-label">exporting…</span>
  <div id="export-progress-wrap">
    <div id="export-progress-bar"></div>
  </div>
</div>

<script>
const COL_GAP   = 80;
const ROW_H     = 22;
const GROUP_GAP = 65;
const NODE_H    = 22;

const _mc = document.createElement('canvas');
const _mx = _mc.getContext('2d');
_mx.font = '400 13px "JetBrains Mono", monospace';
function measureText(label) {
  if (!label) return 40;
  return Math.ceil(_mx.measureText(label).width);
}

// ─── Tree ─────────────────────────────────────────────────────────────────────
let idCounter = 0;
const uid = () => ++idCounter;
let root = null;
const nodes = {};

function createNode(parentId, label = '') {
  const n = { id: uid(), label, children: [], parentId: parentId ?? null };
  nodes[n.id] = n;
  if (parentId != null && nodes[parentId]) nodes[parentId].children.push(n.id);
  return n;
}

function deleteNode(id) {
  const n = nodes[id];
  if (!n) return;
  if (n.parentId != null && nodes[n.parentId]) {
    const arr = nodes[n.parentId].children;
    arr.splice(arr.indexOf(id), 1);
  }
  [...n.children].forEach(deleteNode);
  delete nodes[id];
}

function insertSiblingAfter(id) {
  const n = nodes[id];
  if (!n || n.parentId == null) return null;
  const parent = nodes[n.parentId];
  const sib = { id: uid(), label: '', children: [], parentId: n.parentId };
  nodes[sib.id] = sib;
  parent.children.splice(parent.children.indexOf(id) + 1, 0, sib.id);
  return sib;
}

// ─── Undo / Redo ──────────────────────────────────────────────────────────────
const HISTORY_LIMIT = 60;
let undoStack = [];
let redoStack = [];
let isUndoRedo = false;

function snapshotTree() {
  return JSON.stringify({
    nodes: Object.values(nodes).map(n => ({
      id: n.id, label: n.label, children: [...n.children], parentId: n.parentId
    })),
    rootId: root?.id, idCounter
  });
}

function pushUndo() {
  if (isUndoRedo) return;
  undoStack.push(snapshotTree());
  if (undoStack.length > HISTORY_LIMIT) undoStack.shift();
  redoStack = [];
  updateUndoButtons();
}

function restoreSnapshot(snapshot) {
  const data = JSON.parse(snapshot);
  Object.keys(nodes).forEach(k => delete nodes[k]);
  data.nodes.forEach(n => { nodes[n.id] = { ...n, children: [] }; });
  data.nodes.forEach(n => {
    if (nodes[n.id]) nodes[n.id].children = n.children.filter(cid => nodes[cid]);
  });
  idCounter = data.idCounter;
  root = nodes[data.rootId];
}

function undo() {
  if (!undoStack.length) return;
  redoStack.push(snapshotTree());
  isUndoRedo = true; restoreSnapshot(undoStack.pop()); isUndoRedo = false;
  renderAll(); updateUndoButtons();
}

function redo() {
  if (!redoStack.length) return;
  undoStack.push(snapshotTree());
  isUndoRedo = true; restoreSnapshot(redoStack.pop()); isUndoRedo = false;
  renderAll(); updateUndoButtons();
}

function updateUndoButtons() { /* buttons removed, ctrl+z/y still works */ }

function getThemeColors() {
  const light = window.matchMedia('(prefers-color-scheme: light)').matches;
  return {
    bg:   light ? '#ffffff' : '#1e1e1e',
    text: light ? '#1e1e1e' : '#c8c8c8',
    ph:   light ? '#bbb'    : '#555',
  };
}

// Redraw lines when system theme changes
window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', () => drawLines());


// ─── Arrow key navigation ─────────────────────────────────────────────────────
let selectedNodeId = null;

function selectNode(id) {
  // Clear previous
  if (selectedNodeId && nodeEls[selectedNodeId]) {
    nodeEls[selectedNodeId].labelEl.classList.remove('selected');
  }
  selectedNodeId = id;
  if (id && nodeEls[id]) {
    nodeEls[id].labelEl.classList.add('selected');
    // Scroll into view
    const pos = nodePos[id];
    if (pos) {
      const screenX = pos.x * scale + tx;
      const screenY = pos.y * scale + ty;
      const vw = window.innerWidth, vh = window.innerHeight;
      const PAD = 80;
      if (screenX < PAD) tx += PAD - screenX;
      else if (screenX > vw - PAD) tx -= screenX - (vw - PAD);
      if (screenY < PAD) ty += PAD - screenY;
      else if (screenY > vh - PAD) ty -= screenY - (vh - PAD);
      updateTransform();
    }
  }
}

function getDepth(id) {
  let d = 0, n = nodes[id];
  while (n && n.parentId != null) { d++; n = nodes[n.parentId]; }
  return d;
}

function getNodesSortedByY() {
  return Object.values(nodes)
    .filter(n => nodePos[n.id])
    .sort((a, b) => {
      const ay = nodePos[a.id].y, by = nodePos[b.id].y;
      return ay !== by ? ay - by : nodePos[a.id].x - nodePos[b.id].x;
    });
}

window.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT') return;
  if (e.key === 'Escape') {
    const overlay = document.getElementById('help-overlay');
    if (overlay.classList.contains('visible')) { toggleHelp(); return; }
  }

  if ((e.key === 'Delete' || e.key === 'Backspace') && selectedNodeId && nodes[selectedNodeId]) {
    const n = nodes[selectedNodeId];
    if (n.parentId != null) { // don't delete root
      e.preventDefault();
      pushUndo();
      const parentChildren = nodes[n.parentId]?.children;
      const idx = parentChildren ? parentChildren.indexOf(selectedNodeId) : -1;
      deleteNode(selectedNodeId);
      // Select sibling or parent after deletion
      let nextId = null;
      if (parentChildren && parentChildren.length > 0) {
        nextId = parentChildren[Math.min(idx, parentChildren.length - 1)];
      } else if (n.parentId) {
        nextId = n.parentId;
      }
      selectedNodeId = null;
      renderAll();
      if (nextId && nodes[nextId]) selectNode(nextId);
      saveState();
    }
    return;
  }

  if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); return; }
  if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) { e.preventDefault(); redo(); return; }

  if (e.key === 'Enter' && selectedNodeId && nodes[selectedNodeId] && !e.ctrlKey && !e.metaKey) {
    e.preventDefault();
    startEdit(selectedNodeId);
    return;
  }

  if (!['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) return;
  e.preventDefault();

  const allSorted = getNodesSortedByY();
  if (!allSorted.length) return;

  // If nothing selected, select root
  if (!selectedNodeId || !nodes[selectedNodeId]) {
    selectNode(allSorted[0].id);
    return;
  }

  const cur = nodes[selectedNodeId];
  const depth = getDepth(selectedNodeId);

  if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
    // Only navigate among nodes at same depth
    const sameDepth = allSorted.filter(n => getDepth(n.id) === depth);
    if (!sameDepth.length) return;
    const idx = sameDepth.findIndex(n => n.id === selectedNodeId);
    if (e.key === 'ArrowDown') {
      // Wrap around to top at bottom edge
      const next = sameDepth[(idx + 1) % sameDepth.length];
      selectNode(next.id);
    } else {
      // Wrap around to bottom at top edge
      const prev = sameDepth[(idx - 1 + sameDepth.length) % sameDepth.length];
      selectNode(prev.id);
    }

  } else if (e.key === 'ArrowRight') {
    // Go to first child (closest in Y)
    if (cur.children.length > 0) {
      const curPosY = nodePos[selectedNodeId]?.y ?? 0;
      const best = cur.children
        .map(cid => nodes[cid])
        .filter(Boolean)
        .reduce((a, b) =>
          Math.abs((nodePos[a.id]?.y ?? 0) - curPosY) <= Math.abs((nodePos[b.id]?.y ?? 0) - curPosY) ? a : b
        );
      selectNode(best.id);
    }

  } else if (e.key === 'ArrowLeft') {
    // Go to parent
    if (cur.parentId != null) {
      selectNode(cur.parentId);
    }
  }
});

// ─── Layout ───────────────────────────────────────────────────────────────────
const nodePos = {};
const subtreeHeightCache = {};

function subtreeHeight(id) {
  if (subtreeHeightCache[id] !== undefined) return subtreeHeightCache[id];
  const n = nodes[id];
  if (!n || n.children.length === 0) return (subtreeHeightCache[id] = ROW_H);
  const total = n.children.reduce((s, cid) => s + subtreeHeight(cid), 0);
  return (subtreeHeightCache[id] = Math.max(GROUP_GAP, total));
}

function invalidateHeightCache() {
  Object.keys(subtreeHeightCache).forEach(k => delete subtreeHeightCache[k]);
}

function layoutTree() {
  invalidateHeightCache();
  const maxW = {};
  function measure(id, depth) {
    const n = nodes[id];
    if (!n) return;
    const lbl = (activeEditId === id && nodeEls[id]) ? nodeEls[id].inputEl.value : n.label;
    const w = measureText(lbl);
    if (maxW[depth] === undefined || w > maxW[depth]) maxW[depth] = w;
    n.children.forEach(cid => measure(cid, depth + 1));
  }
  measure(root.id, 0);

  const xAt = {};
  let cx = 0;
  const keys = Object.keys(maxW).map(Number);
  const maxD = keys.length ? Math.max(...keys) : 0;
  for (let d = 0; d <= maxD; d++) {
    xAt[d] = cx;
    cx += (maxW[d] || 0) + COL_GAP;
  }

  function assign(id, depth, y) {
    nodePos[id] = { x: xAt[depth] ?? 0, y };
    let cy = y;
    nodes[id].children.forEach(cid => {
      assign(cid, depth + 1, cy);
      cy += subtreeHeight(cid);
    });
  }
  assign(root.id, 0, 0);
}

// ─── DOM ──────────────────────────────────────────────────────────────────────
const mapContainer = document.getElementById('map-container');
const svgLayer = document.getElementById('svg-layer');
const nodeEls = {};
let suppressBlur = false;
let activeEditId = null;

let dragNodeId   = null;
const dragGhost  = document.getElementById('drag-ghost');
let dropTargetId = null;

function buildDOM() {
  mapContainer.querySelectorAll('.node-el').forEach(e => e.remove());
  svgLayer.innerHTML = '';
  Object.keys(nodeEls).forEach(k => delete nodeEls[k]);

  function buildNode(n) {
    const pos = nodePos[n.id];
    if (!pos) return;

    const el = document.createElement('div');
    el.className = 'node-el node-entering';
    el.dataset.id = n.id;
    el.style.left = pos.x + 'px';
    el.style.top  = pos.y + 'px';

    const labelEl = document.createElement('span');
    labelEl.className = 'node-label' + (n.label === '' ? ' placeholder' : '');
    labelEl.textContent = n.label !== '' ? n.label : (n.parentId == null ? 'type here' : '');

    const inputEl = document.createElement('input');
    inputEl.className = 'node-input';
    inputEl.type = 'text';
    inputEl.value = n.label;
    inputEl.style.display = 'none';

    el.appendChild(labelEl);
    el.appendChild(inputEl);

    nodeEls[n.id] = { el, labelEl, inputEl };
    mapContainer.appendChild(el);

    requestAnimationFrame(() => el.classList.replace('node-entering', 'node-visible'));

    labelEl.addEventListener('dblclick', () => { selectNode(null); startEdit(n.id); });
    if (n.label === '') labelEl.addEventListener('click', () => { selectNode(null); startEdit(n.id); });
    labelEl.addEventListener('click', e => { if (e.detail === 1 && n.label !== '') selectNode(n.id); });

    // ── Drag ──
    labelEl.addEventListener('mousedown', e => {
      if (e.detail >= 2 || e.button !== 0) return;
      const startX = e.clientX, startY = e.clientY;
      let dragging = false;

      const onMove = mv => {
        if (!dragging && (Math.abs(mv.clientX - startX) > 5 || Math.abs(mv.clientY - startY) > 5)) {
          dragging = true;
          dragNodeId = n.id;
          dragGhost.textContent = n.label || '…';
          dragGhost.style.display = 'block';
          el.classList.add('dragging');
          document.body.classList.add('dragging-active');
        }
        if (dragging) {
          dragGhost.style.left = (mv.clientX + 12) + 'px';
          dragGhost.style.top  = (mv.clientY + 8) + 'px';
          updateDropTarget(mv.clientX, mv.clientY, mv.ctrlKey);
        }
      };

      const onUp = () => {
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        if (dragging) {
          el.classList.remove('dragging');
          document.body.classList.remove('dragging-active');
          dragGhost.style.display = 'none';
          commitDrop();
          dragNodeId = null; dropTargetId = null; dropInsert = null;
          clearDropHighlights(); hideDropLine();
        }
      };

      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
    });

    // ── Keyboard ──
    inputEl.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        e.preventDefault(); e.stopPropagation();
        cancelEdit(n.id);
      } else if (e.key === 'Tab') {
        e.preventDefault(); e.stopPropagation();
        const val = inputEl.value.trim();
        if (!val) return; // block child creation if parent is empty
        suppressBlur = true;
        n.label = val;
        activeEditId = null;
        pushUndo();
        const child = createNode(n.id, '');
        renderAll();
        requestAnimationFrame(() => startEdit(child.id));
      } else if (e.key === 'Enter') {
        e.preventDefault(); e.stopPropagation();
        const val = inputEl.value.trim();
        if (!val) return; // stay in edit if empty
        suppressBlur = true;
        activeEditId = null;
        n.label = val;
        if (n.parentId != null) {
          pushUndo();
          const sib = insertSiblingAfter(n.id);
          if (sib) { renderAll(); requestAnimationFrame(() => startEdit(sib.id)); }
        } else { renderAll(); }
      } else {
        e.stopPropagation();
      }
    });

    inputEl.addEventListener('input', () => {
      inputEl.style.width = Math.max(50, inputEl.value.length * 8.5 + 16) + 'px';
      n.label = inputEl.value;
      rerenderPositionsOnly();
    });

    inputEl.addEventListener('blur', () => {
      if (suppressBlur || !document.contains(inputEl)) return;
      if (activeEditId !== n.id) return;
      confirmEdit(n.id);
    });

    n.children.forEach(cid => { if (nodes[cid]) buildNode(nodes[cid]); });
  }

  if (root) buildNode(root);
  drawLines();

  // Restore selection highlight after DOM rebuild
  if (selectedNodeId && nodeEls[selectedNodeId]) {
    nodeEls[selectedNodeId].labelEl.classList.add('selected');
  }
}

// ─── Drag helpers ─────────────────────────────────────────────────────────────
// dropTargetId = reparent target (node id)
// dropInsert   = { parentId, beforeId } for reorder (beforeId=null = append)
let dropInsert = null;

// SVG line showing insert position
let dropLineCoords = null;

function showDropLine(x1, y, x2) {
  dropLineCoords = { x1, y, x2 };
  renderDropLine();
}

function renderDropLine() {
  if (dropLineEl) { dropLineEl.remove(); dropLineEl = null; }
  if (!dropLineCoords) return;
  dropLineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  dropLineEl.setAttribute('class', 'map-line drop-line');
  dropLineEl.setAttribute('x1', dropLineCoords.x1);
  dropLineEl.setAttribute('y1', dropLineCoords.y);
  dropLineEl.setAttribute('x2', dropLineCoords.x2);
  dropLineEl.setAttribute('y2', dropLineCoords.y);
  svgLayer.appendChild(dropLineEl);
}

function hideDropLine() {
  dropLineCoords = null;
  if (dropLineEl) { dropLineEl.remove(); dropLineEl = null; }
}

function updateDropTarget(cx, cy, ctrlKey) {
  clearDropHighlights();
  hideDropLine();
  dropTargetId = null;
  dropInsert = null;

  const rect = mapContainer.getBoundingClientRect();
  const mx = (cx - rect.left) / scale;
  const my = (cy - rect.top)  / scale;

  const dragN = nodes[dragNodeId];
  if (!dragN) return;

  // ── Reparent mode (Ctrl held) ──
  if (ctrlKey) {
    let best = null, bestDist = Infinity;
    Object.values(nodes).forEach(n => {
      if (n.id === dragNodeId) return;
      if (isDescendant(dragNodeId, n.id)) return;
      const pos = nodePos[n.id];
      if (!pos) return;
      const dx = mx - (pos.x + 30), dy = my - (pos.y + NODE_H / 2);
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 60 && dist < bestDist) { bestDist = dist; best = n.id; }
    });
    dropTargetId = best;
    if (best && nodeEls[best]) nodeEls[best].el.classList.add('drop-target');
    return;
  }

  // ── Reorder mode (no Ctrl): only within same parent ──
  if (dragN.parentId == null) return;

  const parent = nodes[dragN.parentId];
  const siblings = parent.children.filter(cid => cid !== dragNodeId);
  if (siblings.length === 0) return;

  const firstSibPos = nodePos[siblings[0]];
  if (!firstSibPos || Math.abs(mx - (firstSibPos.x + 30)) > 80) return;

  // Current position of dragNode in parent's children (with dragNode included)
  const allChildren = parent.children; // includes dragNodeId
  const dragIdx = allChildren.indexOf(dragNodeId);
  // "next sibling" after dragNode in the full list
  const nextSiblingId = allChildren[dragIdx + 1] ?? null;

  const dragPos = nodePos[dragNodeId];
  let insertBefore = null;
  let lineY = null;

  for (let i = 0; i < siblings.length; i++) {
    const sPos = nodePos[siblings[i]];
    if (!sPos) continue;
    if (my < sPos.y + NODE_H / 2) {
      insertBefore = siblings[i];
      const prevPos = i > 0 ? nodePos[siblings[i - 1]] : null;
      const candidateY = prevPos
        ? (prevPos.y + NODE_H / 2 + sPos.y + NODE_H / 2) / 2
        : sPos.y + NODE_H / 2 - ROW_H / 2;
      // Skip if this is the original position (inserting before nextSibling = no change)
      if (insertBefore === nextSiblingId) break;
      // Skip if line would appear at dragNode's own position
      if (dragPos && Math.abs(candidateY - (dragPos.y + NODE_H / 2)) < NODE_H) break;
      lineY = candidateY;
      break;
    }
  }

  if (lineY === null) {
    const lastPos = nodePos[siblings[siblings.length - 1]];
    if (lastPos) {
      // Skip if dragNode is already last (nextSiblingId === null)
      if (nextSiblingId !== null) {
        lineY = lastPos.y + NODE_H / 2 + ROW_H / 2;
      }
    }
  }

  if (lineY !== null) {
    dropInsert = { parentId: dragN.parentId, beforeId: insertBefore };
    const RO = 25, G = 16;
    const railX  = firstSibPos.x - RO;
    const lineLen = RO - G;
    showDropLine(railX - lineLen, lineY, railX);
  }
}

function clearDropHighlights() {
  document.querySelectorAll('.drop-target').forEach(e => e.classList.remove('drop-target'));
}

function isDescendant(ancestorId, nodeId) {
  if (nodeId == null) return false;
  if (nodeId === ancestorId) return true;
  const n = nodes[nodeId];
  if (!n || n.parentId == null) return false;
  return isDescendant(ancestorId, n.parentId);
}

function commitDrop() {
  hideDropLine();
  const dragN = nodes[dragNodeId];
  if (!dragN) return;

  // ── Reorder ──
  if (dropInsert) {
    const { parentId, beforeId } = dropInsert;
    const parent = nodes[parentId];
    if (!parent) return;
    pushUndo();
    // Remove from current position
    const arr = parent.children;
    arr.splice(arr.indexOf(dragNodeId), 1);
    // Insert at new position
    if (beforeId == null) {
      arr.push(dragNodeId);
    } else {
      arr.splice(arr.indexOf(beforeId), 0, dragNodeId);
    }
    renderAll();
    return;
  }

  // ── Reparent ──
  if (!dropTargetId || dragNodeId === dropTargetId) return;
  pushUndo();
  if (dragN.parentId != null && nodes[dragN.parentId]) {
    const arr = nodes[dragN.parentId].children;
    arr.splice(arr.indexOf(dragNodeId), 1);
  }
  dragN.parentId = dropTargetId;
  nodes[dropTargetId].children.push(dragNodeId);
  renderAll();
}

function rerenderPositionsOnly() {
  if (isRendering) return;
  Object.keys(nodePos).forEach(k => delete nodePos[k]);
  layoutTree();
  Object.values(nodes).forEach(n => {
    const pos = nodePos[n.id]; const refs = nodeEls[n.id];
    if (!pos || !refs) return;
    refs.el.style.left = pos.x + 'px';
    refs.el.style.top  = pos.y + 'px';
  });
  drawLines();
}

// ─── Lines ────────────────────────────────────────────────────────────────────
function drawLines() {
  svgLayer.innerHTML = '';
  dropLineEl = null; // cleared by innerHTML reset
  const G = 16, RO = 25;

  Object.values(nodes).forEach(n => {
    if (!n.children.length) return;
    const pPos = nodePos[n.id];
    if (!pPos) return;
    const els = nodeEls[n.id];

    let labelW;
    if (activeEditId === n.id && els && els.inputEl.style.display !== 'none') {
      labelW = els.inputEl.offsetWidth || measureText(els.inputEl.value);
    } else {
      labelW = els ? (els.labelEl.offsetWidth || measureText(n.label)) : measureText(n.label);
    }

    const firstPos = nodePos[n.children[0]];
    const lastPos  = nodePos[n.children[n.children.length - 1]];
    if (!firstPos || !lastPos) return;

    const railX = firstPos.x - RO;
    const stubX = pPos.x + labelW + G;
    const pY    = pPos.y + NODE_H / 2;
    const firstY= firstPos.y + NODE_H / 2;
    const lastY = lastPos.y  + NODE_H / 2;
    const railTop = Math.min(pY, firstY), railBottom = lastY;

    let d;
    if (n.children.length === 1 && firstY === pY) {
      d = `M ${stubX} ${pY} H ${firstPos.x - G}`;
    } else {
      d = `M ${stubX} ${pY} H ${railX} V ${railBottom}`;
      if (railTop < pY) d = `M ${stubX} ${pY} H ${railX} V ${railTop} M ${railX} ${pY} V ${railBottom}`;
    }

    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('class', 'map-line');
    path.setAttribute('d', d);
    svgLayer.appendChild(path);

    n.children.forEach(cid => {
      if (n.children.length === 1 && firstY === pY) return;
      const cPos = nodePos[cid];
      if (!cPos) return;
      const branch = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      branch.setAttribute('class', 'map-line');
      branch.setAttribute('d', `M ${railX} ${cPos.y + NODE_H/2} H ${cPos.x - G}`);
      svgLayer.appendChild(branch);
    });
  });

  // Redraw drop indicator line if active
  renderDropLine();
}

// ─── Edit ─────────────────────────────────────────────────────────────────────
function startEdit(id) {
  const els = nodeEls[id];
  if (!els) return;
  activeEditId = id;
  nodes[id]._originalLabel = nodes[id].label;
  els.el.classList.add('is-editing');
  els.inputEl.style.display = 'inline-block';
  els.inputEl.value = nodes[id]?.label || '';
  els.inputEl.style.width = Math.max(50, Math.max(4, els.inputEl.value.length) * 8.5 + 16) + 'px';

  function updateUnderstroke() {
    const w = els.inputEl.value ? measureText(els.inputEl.value) : 9;
    els.el.style.setProperty('--understroke-w', w + 'px');
  }
  updateUnderstroke();
  els.inputEl._understrokeHandler = updateUnderstroke;
  els.inputEl.addEventListener('input', updateUnderstroke);

  setTimeout(() => { els.inputEl.focus(); els.inputEl.select(); }, 30);
}

function confirmEdit(id) {
  if (activeEditId === id) activeEditId = null;
  const els = nodeEls[id];
  if (!els) return;
  const { el, labelEl, inputEl } = els;
  if (inputEl.style.display === 'none') return;
  if (inputEl._understrokeHandler) {
    inputEl.removeEventListener('input', inputEl._understrokeHandler);
    inputEl._understrokeHandler = null;
  }
  const val = inputEl.value.trim();
  const n = nodes[id];
  if (!n) return;
  if (!val && n.parentId == null && Object.keys(nodes).length === 1) {
    setTimeout(() => inputEl.focus(), 10); return;
  }
  if (!val && n.parentId != null) {
    inputEl.style.display = 'none'; el.classList.remove('is-editing');
    if (n._originalLabel !== undefined) { n.label = n._originalLabel; delete n._originalLabel; }
    deleteNode(id); renderAll(); return;
  }
  pushUndo();
  n.label = val;
  if (n._originalLabel !== undefined) delete n._originalLabel;
  labelEl.textContent = val || 'type here…';
  labelEl.className = 'node-label' + (!val ? ' placeholder' : '');
  el.classList.remove('is-editing');
  inputEl.style.display = 'none';
  renderAll();
}

function cancelEdit(id) {
  if (activeEditId === id) activeEditId = null;
  const n = nodes[id];
  if (!n) return;
  if (n._originalLabel !== undefined) { n.label = n._originalLabel; delete n._originalLabel; }
  if (!n.label && n.parentId != null) { deleteNode(id); renderAll(); return; }
  const els = nodeEls[id];
  if (!els) return;
  els.el.classList.remove('is-editing');
  els.inputEl.style.display = 'none';
  rerenderPositionsOnly();
}

// ─── Render ───────────────────────────────────────────────────────────────────
let isRendering = false;
function renderAll() {
  if (isRendering) return;
  isRendering = true;
  suppressBlur = true; // block stale blur events during DOM rebuild
  Object.keys(nodePos).forEach(k => delete nodePos[k]);
  layoutTree(); buildDOM(); saveState();
  suppressBlur = false;
  isRendering = false;
}

// ─── Pan / Zoom ───────────────────────────────────────────────────────────────
let tx = 100, ty = 80, scale = 1;
let isPanning = false, panStart = null;

function updateTransform() {
  mapContainer.style.transform = `translate(${tx}px,${ty}px) scale(${scale})`;
}

const canvasWrap = document.getElementById('canvas-wrap');
let saveDebounceTimer = null;
function saveDebounced() {
  clearTimeout(saveDebounceTimer);
  saveDebounceTimer = setTimeout(saveState, 300);
}

canvasWrap.addEventListener('wheel', e => {
  e.preventDefault();
  const atMin = scale <= 0.15;
  const atMax = scale >= maxScale();
  const zoomingOut = e.deltaY > 0;
  const zoomingIn  = e.deltaY < 0;
  if ((atMin && zoomingOut) || (atMax && zoomingIn)) return;

  const delta = Math.sign(e.deltaY) * Math.min(Math.abs(e.deltaY), 100);
  const rawF = 1 - delta * 0.0008;

  // Ease strength near limits: t=0 at limit, t=1 far from limit
  const minS = 0.15, maxS = maxScale();
  const range = maxS - minS;
  const easeZone = range * 0.20; // 20% of range = ease zone
  let ease = 1;
  if (zoomingOut) {
    ease = Math.min(1, (scale - minS) / easeZone);
  } else {
    ease = Math.min(1, (maxS - scale) / easeZone);
  }
  ease = ease * ease; // quadratic
  const f = 1 + (rawF - 1) * ease;

  const r = canvasWrap.getBoundingClientRect();
  const mx = e.clientX - r.left, my = e.clientY - r.top;
  tx = mx - (mx - tx) * f; ty = my - (my - ty) * f;
  scale = Math.max(minS, Math.min(maxS, scale * f));
  updateTransform(); saveDebounced();
}, { passive: false });

canvasWrap.addEventListener('mousedown', e => {
  if (e.target.closest('.node-el')) return;
  isPanning = true;
  panStart = { x: e.clientX - tx, y: e.clientY - ty };
  canvasWrap.style.cursor = 'grabbing';
});
window.addEventListener('mousemove', e => {
  if (!isPanning) return;
  tx = e.clientX - panStart.x; ty = e.clientY - panStart.y; updateTransform();
});
window.addEventListener('mouseup', () => {
  if (isPanning) { isPanning = false; canvasWrap.style.cursor = ''; saveState(); }
});

function maxScale() { return (window.innerHeight * 0.05) / NODE_H; }
function zoomIn()    { scale = Math.min(maxScale(), scale * 1.2); updateTransform(); saveState(); }
function zoomOut()   { scale = Math.max(0.15, scale / 1.2); updateTransform(); saveState(); }
function resetZoom() {
  const PAD_X = 60, PAD_Y_TOP = 60, PAD_Y_BOT = 150;
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  Object.values(nodes).forEach(n => {
    if (!n.label) return;
    const pos = nodePos[n.id]; if (!pos) return;
    const w = measureText(n.label);
    minX = Math.min(minX, pos.x);     minY = Math.min(minY, pos.y);
    maxX = Math.max(maxX, pos.x + w); maxY = Math.max(maxY, pos.y + NODE_H);
  });
  if (minX === Infinity) { tx = 100; ty = 80; scale = 1; updateTransform(); return; }

  const treeW = maxX - minX, treeH = maxY - minY;
  const vw = window.innerWidth, vh = window.innerHeight;
  const scaleX = (vw - PAD_X * 2) / treeW;
  const scaleY = (vh - PAD_Y_TOP - PAD_Y_BOT) / treeH;
  const targetScale = Math.min(maxScale(), Math.min(scaleX, scaleY));
  const targetTx = PAD_X - minX * targetScale;
  const targetTy = PAD_Y_TOP - minY * targetScale;

  const startScale = scale, startTx = tx, startTy = ty;
  const duration = 700;
  const startTime = performance.now();
  function easeOut(t) { return 1 - Math.pow(1 - t, 3); }
  function animate(now) {
    const t = Math.min(1, (now - startTime) / duration);
    const e = easeOut(t);
    scale = startScale + (targetScale - startScale) * e;
    tx    = startTx    + (targetTx    - startTx)    * e;
    ty    = startTy    + (targetTy    - startTy)    * e;
    updateTransform();
    if (t < 1) requestAnimationFrame(animate);
    else saveState();
  }
  requestAnimationFrame(animate);
}

// ─── Persistence ──────────────────────────────────────────────────────────────
const STORAGE_KEY = 'mindmap_v2';
function saveState() {
  if (isUndoRedo) return;
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      nodes: Object.values(nodes).map(n => ({
        id: n.id, label: n.label, children: [...n.children], parentId: n.parentId
      })),
      rootId: root?.id, idCounter, tx, ty, scale
    }));
  } catch(e) {}
}

function loadState() {
  try {
    const data = JSON.parse(localStorage.getItem(STORAGE_KEY));
    if (!data?.nodes?.length) return false;
    data.nodes.forEach(n => { nodes[n.id] = { ...n, children: [] }; });
    data.nodes.forEach(n => {
      if (nodes[n.id]) nodes[n.id].children = n.children.filter(cid => nodes[cid]);
    });
    idCounter = data.idCounter || data.nodes.reduce((m, n) => Math.max(m, n.id), 0);
    const rootNode = nodes[data.rootId];
    if (!rootNode) return false;
    root = rootNode;
    tx = data.tx ?? 100; ty = data.ty ?? 80; scale = data.scale ?? 1;
    return true;
  } catch(e) { return false; }
}

let _startOverTipTimer = null;
function toggleHelp() {
  const overlay = document.getElementById('help-overlay');
  if (overlay.classList.contains('visible')) {
    overlay.classList.remove('visible');
    // Hide after transition ends
    overlay.addEventListener('transitionend', () => {
      if (!overlay.classList.contains('visible')) overlay.style.display = 'none';
    }, { once: true });
  } else {
    overlay.style.display = 'block';
    requestAnimationFrame(() => requestAnimationFrame(() => overlay.classList.add('visible')));
  }
}

function startOver(e) {
  if (!e.ctrlKey) {
    const tip = document.getElementById('start-over-tip');
    tip.classList.add('visible');
    clearTimeout(_startOverTipTimer);
    _startOverTipTimer = setTimeout(() => tip.classList.remove('visible'), 1500);
    return;
  }
  pushUndo();
  Object.keys(nodes).forEach(k => delete nodes[k]);
  idCounter = 0; root = createNode(null, '');
  tx = 100; ty = 80; scale = 1;
  updateTransform(); renderAll();
}

const loaded = loadState();
if (!loaded) { root = createNode(null, ''); }
renderAll(); updateTransform();
if (!loaded) { setTimeout(() => startEdit(root.id), 80); }
else {
  const hasContent = Object.values(nodes).some(n => n.label);
  if (hasContent) setTimeout(() => resetZoom(), 80);
}
updateUndoButtons();
</script>

<script>
// ─── Vector SVG export ────────────────────────────────────────────────────────
function buildVectorSVG({ transparent = false } = {}) {
  const colors = getThemeColors();
  const bgColor = colors.bg, textColor = colors.text, phColor = colors.ph;

  const PADDING = 60;
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  Object.values(nodes).forEach(n => {
    const pos = nodePos[n.id]; if (!pos) return;
    const w = measureText(n.label || 'type here…');
    minX = Math.min(minX, pos.x); minY = Math.min(minY, pos.y);
    maxX = Math.max(maxX, pos.x + w); maxY = Math.max(maxY, pos.y + NODE_H);
  });

  const W = maxX - minX + PADDING * 2, H = maxY - minY + PADDING * 2;
  const ox = -minX + PADDING, oy = -minY + PADDING;

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  svg.setAttribute('width', W); svg.setAttribute('height', H);
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

  if (!transparent) {
    const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    bgRect.setAttribute('width', '100%'); bgRect.setAttribute('height', '100%');
    bgRect.setAttribute('fill', bgColor); svg.appendChild(bgRect);
  }

  const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  g.setAttribute('transform', `translate(${ox},${oy})`);
  const G = 16, RO = 25;

  Object.values(nodes).forEach(n => {
    if (!n.children.length) return;
    const pPos = nodePos[n.id]; if (!pPos) return;
    const labelW = measureText(n.label);
    const firstPos = nodePos[n.children[0]];
    const lastPos  = nodePos[n.children[n.children.length - 1]];
    if (!firstPos || !lastPos) return;

    const railX = firstPos.x - RO, stubX = pPos.x + labelW + G;
    const pY = pPos.y + NODE_H/2, firstY = firstPos.y + NODE_H/2, lastY = lastPos.y + NODE_H/2;
    const railTop = Math.min(pY, firstY), railBottom = lastY;

    let d;
    if (n.children.length === 1 && firstY === pY) {
      d = `M ${stubX} ${pY} H ${firstPos.x - G}`;
    } else {
      d = `M ${stubX} ${pY} H ${railX} V ${railBottom}`;
      if (railTop < pY) d = `M ${stubX} ${pY} H ${railX} V ${railTop} M ${railX} ${pY} V ${railBottom}`;
    }

    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('stroke', textColor); path.setAttribute('stroke-width', '1');
    path.setAttribute('stroke-linecap', 'square'); path.setAttribute('stroke-linejoin', 'miter');
    path.setAttribute('fill', 'none'); path.setAttribute('d', d);
    g.appendChild(path);

    n.children.forEach(cid => {
      if (n.children.length === 1 && firstY === pY) return;
      const cPos = nodePos[cid]; if (!cPos) return;
      const branch = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      branch.setAttribute('stroke', textColor); branch.setAttribute('stroke-width', '1');
      branch.setAttribute('stroke-linecap', 'square'); branch.setAttribute('fill', 'none');
      branch.setAttribute('d', `M ${railX} ${cPos.y + NODE_H/2} H ${cPos.x - G}`);
      g.appendChild(branch);
    });
  });

  Object.values(nodes).forEach(n => {
    const pos = nodePos[n.id]; if (!pos) return;
    const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    textEl.setAttribute('x', pos.x); textEl.setAttribute('y', pos.y + 15);
    textEl.setAttribute('font-family', 'JetBrains Mono, monospace');
    textEl.setAttribute('font-size', '13'); textEl.setAttribute('font-weight', '400');
    textEl.setAttribute('fill', n.label ? textColor : phColor);
    textEl.setAttribute('letter-spacing', '0.01em');
    textEl.textContent = n.label || (n.parentId == null ? 'type here…' : '…');
    g.appendChild(textEl);
  });

  svg.appendChild(g);
  return { svg, W, H, bgColor };
}

function exportSVG() {
  const { svg } = buildVectorSVG({ transparent: false });
  const name = (root?.label || 'mindmap').replace(/[^a-z0-9_-]/gi, '_').toLowerCase();
  const blob = new Blob([new XMLSerializer().serializeToString(svg)], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = name + '.svg'; a.click();
  URL.revokeObjectURL(url);
}

const RASTER_SCALE = 9;
function setProgress(pct, label) {
  document.getElementById('export-progress-bar').style.width = pct + '%';
  document.getElementById('export-label').textContent = label;
}

async function exportRaster(format) {
  const overlay = document.getElementById('export-overlay');
  overlay.classList.add('visible');
  setProgress(0, `exporting ${format}…`);
  await new Promise(r => setTimeout(r, 60));

  try {
    const isPNG = format === 'png';
    const { svg, W, H, bgColor } = buildVectorSVG({ transparent: isPNG });
    setProgress(15, 'loading font…');
    await new Promise(r => setTimeout(r, 30));

    let fontFace = '';
    try {
      const fontResp = await fetch(
        'https://fonts.gstatic.com/s/jetbrainsmono/v18/tDbY2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKxTOlOTk6OThhvAWV8.woff2'
      );
      if (fontResp.ok) {
        const buf = await fontResp.arrayBuffer();
        const bytes = new Uint8Array(buf);
        let binary = '';
        for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
        fontFace = `<defs><style>@font-face{font-family:'JetBrains Mono';font-weight:400;src:url('data:font/woff2;base64,${btoa(binary)}') format('woff2');}</style></defs>`;
      }
    } catch(_) {}

    setProgress(35, 'rendering svg…');
    await new Promise(r => setTimeout(r, 30));

    let svgStr = new XMLSerializer().serializeToString(svg);
    if (fontFace) svgStr = svgStr.replace(/<svg([^>]*)>/, `<svg$1>${fontFace}`);

    const svgBlob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
    const svgUrl  = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgStr);

    setProgress(55, 'drawing canvas…');
    const img = new Image();
    img.width  = W * RASTER_SCALE;
    img.height = H * RASTER_SCALE;
    await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = svgUrl; });

    const canvas = document.createElement('canvas');
    canvas.width  = W * RASTER_SCALE; canvas.height = H * RASTER_SCALE;
    const ctx = canvas.getContext('2d');

    setProgress(75, 'compositing…');
    await new Promise(r => setTimeout(r, 30));

    ctx.fillStyle = bgColor;
    if (!isPNG) ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    setProgress(90, 'encoding…');
    await new Promise(r => setTimeout(r, 30));

    const name = (root?.label || 'mindmap').replace(/[^a-z0-9_-]/gi, '_').toLowerCase();
    const mimeType = isPNG ? 'image/png' : 'image/jpeg';
    const quality  = isPNG ? undefined : 0.95;

    const fileBlob = await new Promise(res => canvas.toBlob(res, mimeType, quality));
    const fileUrl  = URL.createObjectURL(fileBlob);
    const a = document.createElement('a');
    a.href = fileUrl; a.download = `${name}.${format}`; a.click();
    setTimeout(() => URL.revokeObjectURL(fileUrl), 1000);

    setProgress(100, 'done ✓');
    await new Promise(r => setTimeout(r, 500));
  } catch(err) {
    console.error('Export error:', err);
    setProgress(0, 'error ✗');
    await new Promise(r => setTimeout(r, 1000));
  } finally {
    overlay.classList.remove('visible');
    setProgress(0, '');
  }
}
</script>
</body>
</html>
