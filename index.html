<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mind Map</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  /* ── Themes ── */
  :root {
    --bg:             #1e1e1e;
    --text:           #c8c8c8;
    --placeholder:    #555;
    --border:         #3a3a3a;
    --btn-bg:         #1e1e1e;
    --drop-bg:        #2e2e2e;
    --sel-bg:         #3a3a3a;
    --overlay-bg:     rgba(30,30,30,0.92);
    --progress-track: #333;
    --del-color:      #444;
  }
  @media (prefers-color-scheme: light) {
    :root {
      --bg:             #ffffff;
      --text:           #1e1e1e;
      --placeholder:    #bbb;
      --border:         #d0ceca;
      --btn-bg:         #ffffff;
      --drop-bg:        #e8e6e0;
      --sel-bg:         #d0ceca;
      --overlay-bg:     rgba(255,255,255,0.92);
      --progress-track: #ddd;
      --del-color:      #ccc;
    }
  }

  ::selection { background: var(--sel-bg); color: var(--text); }

  body {
    background: var(--bg);
    font-family: 'JetBrains Mono', monospace;
    overflow: hidden;
    width: 100vw; height: 100vh;
    cursor: default;
    user-select: none;
    transition: background 0.2s;
  }

  #canvas-wrap {
    width: 100%; height: 100%;
    position: relative;
    overflow: hidden;
  }

  #map-container {
    position: absolute;
    top: 0; left: 0;
    transform-origin: 0 0;
    z-index: 2;
  }

  #svg-layer {
    position: absolute;
    top: 0; left: 0;
    width: 9999px; height: 9999px;
    pointer-events: none;
    z-index: 1;
    overflow: visible;
  }

  .node-el {
    position: absolute;
    display: flex;
    align-items: center;
    height: 22px;
    white-space: nowrap;
    transition: top 0.15s ease, left 0.15s ease, opacity 0.15s ease;
  }

  .node-el.node-entering { opacity: 0; }
  .node-el.node-visible  { opacity: 1; }

  .node-label {
    font-size: 13px;
    font-weight: 400;
    color: var(--text);
    letter-spacing: 0.01em;
    cursor: pointer;
    white-space: nowrap;
    padding: 1px 4px;
    border-radius: 2px;
    transition: background 0.1s;
  }
  .node-label.placeholder { color: var(--placeholder); cursor: text; }
  .node-label.placeholder::after {
    content: '';
    animation: dots 1.5s infinite;
  }
  @keyframes dots {
    0%   { content: ''; }
    25%  { content: '.'; }
    50%  { content: '..'; }
    75%  { content: '...'; }
    100% { content: ''; }
  }

  .node-el.is-editing .node-label { display: none; }
  .node-input {
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    font-weight: 400;
    color: var(--text);
    background: transparent;
    border: none;
    outline: none;
    padding: 1px 4px;
    border-radius: 2px;
    min-width: 50px;
    width: 80px;
    letter-spacing: 0.01em;
    user-select: text;
  }

  .node-del {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 14px; height: 14px;
    border: none;
    background: transparent;
    color: var(--del-color);
    font-size: 13px;
    cursor: pointer;
    margin-left: 1px; margin-right: 1px;
    flex-shrink: 0;
    transition: color 0.1s;
    opacity: 0;
    pointer-events: none;
  }
  .node-el:hover .node-del { opacity: 1; pointer-events: auto; }
  body.dragging-active .node-del { opacity: 0 !important; pointer-events: none !important; }
  .node-del:hover { color: #d44; }

  .node-el.dragging { opacity: 0.35; pointer-events: none; }
  #drag-ghost {
    position: fixed;
    pointer-events: none;
    z-index: 999;
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    color: var(--text);
    background: var(--btn-bg);
    border: 1px solid var(--border);
    padding: 2px 8px;
    border-radius: 2px;
    display: none;
    white-space: nowrap;
    box-shadow: 0 2px 8px rgba(0,0,0,0.4);
  }

  .node-el.drop-target .node-label { background: var(--drop-bg); }

  .map-line {
    stroke: var(--text);
    stroke-width: 1px;
    fill: none;
    stroke-linecap: square;
    stroke-linejoin: miter;
  }
  .map-line.drop-line {
    stroke: var(--text);
    stroke-width: 1px;
  }

  #controls {
    position: fixed;
    bottom: 24px; right: 24px;
    display: flex; gap: 6px;
    z-index: 100;
    align-items: center;
  }

  .ctrl-btn {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: var(--text);
    background: var(--btn-bg);
    border: 1px solid var(--border);
    padding: 5px 12px;
    cursor: pointer;
    border-radius: 2px;
    letter-spacing: 0.02em;
    transition: border-color 0.1s, color 0.1s, opacity 0.15s;
    height: 28px;
  }
  .ctrl-btn:hover { border-color: var(--text); color: var(--text); }
  .ctrl-btn:disabled { opacity: 0.3; cursor: default; pointer-events: none; }

  #btn-start-over { color: #c87; border-color: #5a3a3a; }
  #btn-start-over:hover { border-color: #d44; color: #d44; }

  #hint {
    position: fixed;
    bottom: 24px; left: 24px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text);
    z-index: 100;
    line-height: 1.9;
    pointer-events: none;
    display: flex;
    flex-direction: column;
    gap: 2px;
  }

  #export-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: var(--overlay-bg);
    z-index: 200;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 16px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: var(--placeholder);
    letter-spacing: 0.04em;
  }
  #export-overlay.visible { display: flex; }
  #export-progress-wrap {
    width: 180px; height: 2px;
    background: var(--progress-track); border-radius: 1px; overflow: hidden;
  }
  #export-progress-bar {
    height: 100%; width: 0%;
    background: #c8c8c8;
    transition: width 0.2s ease;
    border-radius: 1px;
  }
</style>
</head>
<body>

<div id="canvas-wrap">
  <div id="map-container">
    <svg id="svg-layer"></svg>
  </div>
</div>

<div id="drag-ghost"></div>

<div id="controls">
  <button class="ctrl-btn" onclick="exportSVG()">svg</button>
  <button class="ctrl-btn" onclick="exportRaster('png')">png</button>
  <button class="ctrl-btn" onclick="exportRaster('jpeg')">jpeg</button>
  <button class="ctrl-btn" onclick="resetZoom()">reset view</button>
  <button class="ctrl-btn" onclick="zoomOut()">−</button>
  <button class="ctrl-btn" onclick="zoomIn()">+</button>
  <button class="ctrl-btn" id="btn-start-over" onclick="startOver(event)">start over</button>
</div>

<div id="hint">
  <div>tab → child</div>
  <div>enter → sibling</div>
  <div>ctrl+z → undo &nbsp; ctrl+y → redo</div>
  <div>drag → reorder &nbsp; ctrl+drag → reparent</div>
  <div>ctrl + start over → reset map</div>
</div>

<div id="export-overlay">
  <span id="export-label">exporting…</span>
  <div id="export-progress-wrap">
    <div id="export-progress-bar"></div>
  </div>
</div>

<script>
const COL_GAP   = 80;
const ROW_H     = 22;
const GROUP_GAP = 65;
const NODE_H    = 22;

const _mc = document.createElement('canvas');
const _mx = _mc.getContext('2d');
_mx.font = '400 13px "JetBrains Mono", monospace';
function measureText(label) {
  if (!label) return 40;
  return Math.ceil(_mx.measureText(label).width);
}

// ─── Tree ─────────────────────────────────────────────────────────────────────
let idCounter = 0;
const uid = () => ++idCounter;
let root = null;
const nodes = {};

function createNode(parentId, label = '') {
  const n = { id: uid(), label, children: [], parentId: parentId ?? null };
  nodes[n.id] = n;
  if (parentId != null && nodes[parentId]) nodes[parentId].children.push(n.id);
  return n;
}

function deleteNode(id) {
  const n = nodes[id];
  if (!n) return;
  if (n.parentId != null && nodes[n.parentId]) {
    const arr = nodes[n.parentId].children;
    arr.splice(arr.indexOf(id), 1);
  }
  [...n.children].forEach(deleteNode);
  delete nodes[id];
}

function insertSiblingAfter(id) {
  const n = nodes[id];
  if (!n || n.parentId == null) return null;
  const parent = nodes[n.parentId];
  const sib = { id: uid(), label: '', children: [], parentId: n.parentId };
  nodes[sib.id] = sib;
  parent.children.splice(parent.children.indexOf(id) + 1, 0, sib.id);
  return sib;
}

// ─── Undo / Redo ──────────────────────────────────────────────────────────────
const HISTORY_LIMIT = 60;
let undoStack = [];
let redoStack = [];
let isUndoRedo = false;

function snapshotTree() {
  return JSON.stringify({
    nodes: Object.values(nodes).map(n => ({
      id: n.id, label: n.label, children: [...n.children], parentId: n.parentId
    })),
    rootId: root?.id, idCounter
  });
}

function pushUndo() {
  if (isUndoRedo) return;
  undoStack.push(snapshotTree());
  if (undoStack.length > HISTORY_LIMIT) undoStack.shift();
  redoStack = [];
  updateUndoButtons();
}

function restoreSnapshot(snapshot) {
  const data = JSON.parse(snapshot);
  Object.keys(nodes).forEach(k => delete nodes[k]);
  data.nodes.forEach(n => { nodes[n.id] = { ...n, children: [] }; });
  data.nodes.forEach(n => {
    if (nodes[n.id]) nodes[n.id].children = n.children.filter(cid => nodes[cid]);
  });
  idCounter = data.idCounter;
  root = nodes[data.rootId];
}

function undo() {
  if (!undoStack.length) return;
  redoStack.push(snapshotTree());
  isUndoRedo = true; restoreSnapshot(undoStack.pop()); isUndoRedo = false;
  renderAll(); updateUndoButtons();
}

function redo() {
  if (!redoStack.length) return;
  undoStack.push(snapshotTree());
  isUndoRedo = true; restoreSnapshot(redoStack.pop()); isUndoRedo = false;
  renderAll(); updateUndoButtons();
}

function updateUndoButtons() { /* buttons removed, ctrl+z/y still works */ }

function getThemeColors() {
  const light = window.matchMedia('(prefers-color-scheme: light)').matches;
  return {
    bg:   light ? '#ffffff' : '#1e1e1e',
    text: light ? '#1e1e1e' : '#c8c8c8',
    ph:   light ? '#bbb'    : '#555',
  };
}

// Redraw lines when system theme changes
window.matchMedia('(prefers-color-scheme: light)').addEventListener('change', () => drawLines());


window.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT') return;
  if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); }
  if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) { e.preventDefault(); redo(); }
});

// ─── Layout ───────────────────────────────────────────────────────────────────
const nodePos = {};
const subtreeHeightCache = {};

function subtreeHeight(id) {
  if (subtreeHeightCache[id] !== undefined) return subtreeHeightCache[id];
  const n = nodes[id];
  if (!n || n.children.length === 0) return (subtreeHeightCache[id] = ROW_H);
  const total = n.children.reduce((s, cid) => s + subtreeHeight(cid), 0);
  return (subtreeHeightCache[id] = Math.max(GROUP_GAP, total));
}

function invalidateHeightCache() {
  Object.keys(subtreeHeightCache).forEach(k => delete subtreeHeightCache[k]);
}

function layoutTree() {
  invalidateHeightCache();
  const maxW = {};
  function measure(id, depth) {
    const n = nodes[id];
    if (!n) return;
    const lbl = (activeEditId === id && nodeEls[id]) ? nodeEls[id].inputEl.value : n.label;
    const w = measureText(lbl);
    if (maxW[depth] === undefined || w > maxW[depth]) maxW[depth] = w;
    n.children.forEach(cid => measure(cid, depth + 1));
  }
  measure(root.id, 0);

  const xAt = {};
  let cx = 0;
  const keys = Object.keys(maxW).map(Number);
  const maxD = keys.length ? Math.max(...keys) : 0;
  for (let d = 0; d <= maxD; d++) {
    xAt[d] = cx;
    cx += (maxW[d] || 0) + COL_GAP;
  }

  function assign(id, depth, y) {
    nodePos[id] = { x: xAt[depth] ?? 0, y };
    let cy = y;
    nodes[id].children.forEach(cid => {
      assign(cid, depth + 1, cy);
      cy += subtreeHeight(cid);
    });
  }
  assign(root.id, 0, 0);
}

// ─── DOM ──────────────────────────────────────────────────────────────────────
const mapContainer = document.getElementById('map-container');
const svgLayer = document.getElementById('svg-layer');
const nodeEls = {};
let suppressBlur = false;
let activeEditId = null;

let dragNodeId   = null;
const dragGhost  = document.getElementById('drag-ghost');
let dropTargetId = null;

function buildDOM() {
  mapContainer.querySelectorAll('.node-el').forEach(e => e.remove());
  svgLayer.innerHTML = '';
  Object.keys(nodeEls).forEach(k => delete nodeEls[k]);

  function buildNode(n) {
    const pos = nodePos[n.id];
    if (!pos) return;

    const el = document.createElement('div');
    el.className = 'node-el node-entering';
    el.dataset.id = n.id;
    el.style.left = pos.x + 'px';
    el.style.top  = pos.y + 'px';

    const labelEl = document.createElement('span');
    labelEl.className = 'node-label' + (n.label === '' ? ' placeholder' : '');
    labelEl.textContent = n.label !== '' ? n.label : (n.parentId == null ? 'type here' : '');

    const inputEl = document.createElement('input');
    inputEl.className = 'node-input';
    inputEl.type = 'text';
    inputEl.value = n.label;
    inputEl.style.display = 'none';

    const delBtn = document.createElement('span');
    delBtn.className = 'node-del';
    delBtn.innerHTML = '×';

    el.appendChild(labelEl);
    el.appendChild(inputEl);
    if (n.parentId != null) {
      delBtn.addEventListener('mousedown', () => { suppressBlur = true; });
      delBtn.addEventListener('click', () => {
        setTimeout(() => { suppressBlur = false; }, 0);
        pushUndo(); deleteNode(n.id); renderAll();
      });
      el.appendChild(delBtn);
    }

    nodeEls[n.id] = { el, labelEl, inputEl };
    mapContainer.appendChild(el);

    requestAnimationFrame(() => el.classList.replace('node-entering', 'node-visible'));

    labelEl.addEventListener('dblclick', () => startEdit(n.id));
    if (n.label === '') labelEl.addEventListener('click', () => startEdit(n.id));

    // ── Drag ──
    labelEl.addEventListener('mousedown', e => {
      if (e.detail >= 2 || e.button !== 0) return;
      const startX = e.clientX, startY = e.clientY;
      let dragging = false;

      const onMove = mv => {
        if (!dragging && (Math.abs(mv.clientX - startX) > 5 || Math.abs(mv.clientY - startY) > 5)) {
          dragging = true;
          dragNodeId = n.id;
          dragGhost.textContent = n.label || '…';
          dragGhost.style.display = 'block';
          el.classList.add('dragging');
          document.body.classList.add('dragging-active');
        }
        if (dragging) {
          dragGhost.style.left = (mv.clientX + 12) + 'px';
          dragGhost.style.top  = (mv.clientY + 8) + 'px';
          updateDropTarget(mv.clientX, mv.clientY, mv.ctrlKey);
        }
      };

      const onUp = () => {
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        if (dragging) {
          el.classList.remove('dragging');
          document.body.classList.remove('dragging-active');
          dragGhost.style.display = 'none';
          commitDrop();
          dragNodeId = null; dropTargetId = null; dropInsert = null;
          clearDropHighlights(); hideDropLine();
        }
      };

      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
    });

    // ── Keyboard ──
    inputEl.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        e.preventDefault(); e.stopPropagation();
        cancelEdit(n.id);
      } else if (e.key === 'Tab') {
        e.preventDefault(); e.stopPropagation();
        // suppressBlur stays true — renderAll() will reset it
        suppressBlur = true;
        n.label = inputEl.value.trim() || n.label;
        activeEditId = null;
        pushUndo();
        const child = createNode(n.id, '');
        renderAll();
        requestAnimationFrame(() => startEdit(child.id));
      } else if (e.key === 'Enter') {
        e.preventDefault(); e.stopPropagation();
        suppressBlur = true;
        const val = inputEl.value.trim();
        activeEditId = null;
        if (!val && n.parentId != null) {
          deleteNode(n.id); renderAll(); return;
        }
        n.label = val || n.label;
        if (n.parentId != null) {
          pushUndo();
          const sib = insertSiblingAfter(n.id);
          if (sib) { renderAll(); requestAnimationFrame(() => startEdit(sib.id)); }
        } else { renderAll(); }
      } else {
        e.stopPropagation();
      }
    });

    inputEl.addEventListener('input', () => {
      inputEl.style.width = Math.max(50, inputEl.value.length * 8.5 + 16) + 'px';
      n.label = inputEl.value;
      rerenderPositionsOnly();
    });

    inputEl.addEventListener('blur', () => {
      if (suppressBlur || !document.contains(inputEl)) return;
      if (activeEditId !== n.id) return;
      confirmEdit(n.id);
    });

    n.children.forEach(cid => { if (nodes[cid]) buildNode(nodes[cid]); });
  }

  if (root) buildNode(root);
  drawLines();
}

// ─── Drag helpers ─────────────────────────────────────────────────────────────
// dropTargetId = reparent target (node id)
// dropInsert   = { parentId, beforeId } for reorder (beforeId=null = append)
let dropInsert = null;

// SVG line showing insert position
let dropLineCoords = null;

function showDropLine(x1, y, x2) {
  dropLineCoords = { x1, y, x2 };
  renderDropLine();
}

function renderDropLine() {
  if (dropLineEl) { dropLineEl.remove(); dropLineEl = null; }
  if (!dropLineCoords) return;
  dropLineEl = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  dropLineEl.setAttribute('class', 'map-line drop-line');
  dropLineEl.setAttribute('x1', dropLineCoords.x1);
  dropLineEl.setAttribute('y1', dropLineCoords.y);
  dropLineEl.setAttribute('x2', dropLineCoords.x2);
  dropLineEl.setAttribute('y2', dropLineCoords.y);
  svgLayer.appendChild(dropLineEl);
}

function hideDropLine() {
  dropLineCoords = null;
  if (dropLineEl) { dropLineEl.remove(); dropLineEl = null; }
}

function updateDropTarget(cx, cy, ctrlKey) {
  clearDropHighlights();
  hideDropLine();
  dropTargetId = null;
  dropInsert = null;

  const rect = mapContainer.getBoundingClientRect();
  const mx = (cx - rect.left) / scale;
  const my = (cy - rect.top)  / scale;

  const dragN = nodes[dragNodeId];
  if (!dragN) return;

  // ── Reparent mode (Ctrl held) ──
  if (ctrlKey) {
    let best = null, bestDist = Infinity;
    Object.values(nodes).forEach(n => {
      if (n.id === dragNodeId) return;
      if (isDescendant(dragNodeId, n.id)) return;
      const pos = nodePos[n.id];
      if (!pos) return;
      const dx = mx - (pos.x + 30), dy = my - (pos.y + NODE_H / 2);
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < 60 && dist < bestDist) { bestDist = dist; best = n.id; }
    });
    dropTargetId = best;
    if (best && nodeEls[best]) nodeEls[best].el.classList.add('drop-target');
    return;
  }

  // ── Reorder mode (no Ctrl): only within same parent ──
  if (dragN.parentId == null) return;

  const parent = nodes[dragN.parentId];
  const siblings = parent.children.filter(cid => cid !== dragNodeId);
  if (siblings.length === 0) return;

  const firstSibPos = nodePos[siblings[0]];
  if (!firstSibPos || Math.abs(mx - (firstSibPos.x + 30)) > 80) return;

  // Current position of dragNode in parent's children (with dragNode included)
  const allChildren = parent.children; // includes dragNodeId
  const dragIdx = allChildren.indexOf(dragNodeId);
  // "next sibling" after dragNode in the full list
  const nextSiblingId = allChildren[dragIdx + 1] ?? null;

  const dragPos = nodePos[dragNodeId];
  let insertBefore = null;
  let lineY = null;

  for (let i = 0; i < siblings.length; i++) {
    const sPos = nodePos[siblings[i]];
    if (!sPos) continue;
    if (my < sPos.y + NODE_H / 2) {
      insertBefore = siblings[i];
      const prevPos = i > 0 ? nodePos[siblings[i - 1]] : null;
      const candidateY = prevPos
        ? (prevPos.y + NODE_H / 2 + sPos.y + NODE_H / 2) / 2
        : sPos.y + NODE_H / 2 - ROW_H / 2;
      // Skip if this is the original position (inserting before nextSibling = no change)
      if (insertBefore === nextSiblingId) break;
      // Skip if line would appear at dragNode's own position
      if (dragPos && Math.abs(candidateY - (dragPos.y + NODE_H / 2)) < NODE_H) break;
      lineY = candidateY;
      break;
    }
  }

  if (lineY === null) {
    const lastPos = nodePos[siblings[siblings.length - 1]];
    if (lastPos) {
      // Skip if dragNode is already last (nextSiblingId === null)
      if (nextSiblingId !== null) {
        lineY = lastPos.y + NODE_H / 2 + ROW_H / 2;
      }
    }
  }

  if (lineY !== null) {
    dropInsert = { parentId: dragN.parentId, beforeId: insertBefore };
    const RO = 25, G = 16;
    const railX  = firstSibPos.x - RO;
    const lineLen = RO - G;
    showDropLine(railX - lineLen, lineY, railX);
  }
}

function clearDropHighlights() {
  document.querySelectorAll('.drop-target').forEach(e => e.classList.remove('drop-target'));
}

function isDescendant(ancestorId, nodeId) {
  if (nodeId == null) return false;
  if (nodeId === ancestorId) return true;
  const n = nodes[nodeId];
  if (!n || n.parentId == null) return false;
  return isDescendant(ancestorId, n.parentId);
}

function commitDrop() {
  hideDropLine();
  const dragN = nodes[dragNodeId];
  if (!dragN) return;

  // ── Reorder ──
  if (dropInsert) {
    const { parentId, beforeId } = dropInsert;
    const parent = nodes[parentId];
    if (!parent) return;
    pushUndo();
    // Remove from current position
    const arr = parent.children;
    arr.splice(arr.indexOf(dragNodeId), 1);
    // Insert at new position
    if (beforeId == null) {
      arr.push(dragNodeId);
    } else {
      arr.splice(arr.indexOf(beforeId), 0, dragNodeId);
    }
    renderAll();
    return;
  }

  // ── Reparent ──
  if (!dropTargetId || dragNodeId === dropTargetId) return;
  pushUndo();
  if (dragN.parentId != null && nodes[dragN.parentId]) {
    const arr = nodes[dragN.parentId].children;
    arr.splice(arr.indexOf(dragNodeId), 1);
  }
  dragN.parentId = dropTargetId;
  nodes[dropTargetId].children.push(dragNodeId);
  renderAll();
}

function rerenderPositionsOnly() {
  if (isRendering) return;
  Object.keys(nodePos).forEach(k => delete nodePos[k]);
  layoutTree();
  Object.values(nodes).forEach(n => {
    const pos = nodePos[n.id]; const refs = nodeEls[n.id];
    if (!pos || !refs) return;
    refs.el.style.left = pos.x + 'px';
    refs.el.style.top  = pos.y + 'px';
  });
  drawLines();
}

// ─── Lines ────────────────────────────────────────────────────────────────────
function drawLines() {
  svgLayer.innerHTML = '';
  dropLineEl = null; // cleared by innerHTML reset
  const G = 16, RO = 25;

  Object.values(nodes).forEach(n => {
    if (!n.children.length) return;
    const pPos = nodePos[n.id];
    if (!pPos) return;
    const els = nodeEls[n.id];

    let labelW;
    if (activeEditId === n.id && els && els.inputEl.style.display !== 'none') {
      labelW = els.inputEl.offsetWidth || measureText(els.inputEl.value);
    } else {
      labelW = els ? (els.labelEl.offsetWidth || measureText(n.label)) : measureText(n.label);
    }

    const firstPos = nodePos[n.children[0]];
    const lastPos  = nodePos[n.children[n.children.length - 1]];
    if (!firstPos || !lastPos) return;

    const railX = firstPos.x - RO;
    const stubX = pPos.x + labelW + G;
    const pY    = pPos.y + NODE_H / 2;
    const firstY= firstPos.y + NODE_H / 2;
    const lastY = lastPos.y  + NODE_H / 2;
    const railTop = Math.min(pY, firstY), railBottom = lastY;

    let d;
    if (n.children.length === 1 && firstY === pY) {
      d = `M ${stubX} ${pY} H ${firstPos.x - G}`;
    } else {
      d = `M ${stubX} ${pY} H ${railX} V ${railBottom}`;
      if (railTop < pY) d = `M ${stubX} ${pY} H ${railX} V ${railTop} M ${railX} ${pY} V ${railBottom}`;
    }

    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('class', 'map-line');
    path.setAttribute('d', d);
    svgLayer.appendChild(path);

    n.children.forEach(cid => {
      if (n.children.length === 1 && firstY === pY) return;
      const cPos = nodePos[cid];
      if (!cPos) return;
      const branch = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      branch.setAttribute('class', 'map-line');
      branch.setAttribute('d', `M ${railX} ${cPos.y + NODE_H/2} H ${cPos.x - G}`);
      svgLayer.appendChild(branch);
    });
  });

  // Redraw drop indicator line if active
  renderDropLine();
}

// ─── Edit ─────────────────────────────────────────────────────────────────────
function startEdit(id) {
  const els = nodeEls[id];
  if (!els) return;
  activeEditId = id;
  nodes[id]._originalLabel = nodes[id].label;
  els.el.classList.add('is-editing');
  els.inputEl.style.display = 'inline-block';
  els.inputEl.value = nodes[id]?.label || '';
  els.inputEl.style.width = Math.max(50, Math.max(4, els.inputEl.value.length) * 8.5 + 16) + 'px';
  setTimeout(() => { els.inputEl.focus(); els.inputEl.select(); }, 30);
}

function confirmEdit(id) {
  if (activeEditId === id) activeEditId = null;
  const els = nodeEls[id];
  if (!els) return;
  const { el, labelEl, inputEl } = els;
  if (inputEl.style.display === 'none') return;
  const val = inputEl.value.trim();
  const n = nodes[id];
  if (!n) return;
  if (!val && n.parentId == null && Object.keys(nodes).length === 1) {
    setTimeout(() => inputEl.focus(), 10); return;
  }
  if (!val && n.parentId != null) {
    inputEl.style.display = 'none'; el.classList.remove('is-editing');
    if (n._originalLabel !== undefined) { n.label = n._originalLabel; delete n._originalLabel; }
    deleteNode(id); renderAll(); return;
  }
  pushUndo();
  n.label = val;
  if (n._originalLabel !== undefined) delete n._originalLabel;
  labelEl.textContent = val || 'type here…';
  labelEl.className = 'node-label' + (!val ? ' placeholder' : '');
  el.classList.remove('is-editing');
  inputEl.style.display = 'none';
  renderAll();
}

function cancelEdit(id) {
  if (activeEditId === id) activeEditId = null;
  const n = nodes[id];
  if (!n) return;
  if (n._originalLabel !== undefined) { n.label = n._originalLabel; delete n._originalLabel; }
  if (!n.label && n.parentId != null) { deleteNode(id); renderAll(); return; }
  const els = nodeEls[id];
  if (!els) return;
  els.el.classList.remove('is-editing');
  els.inputEl.style.display = 'none';
  rerenderPositionsOnly();
}

// ─── Render ───────────────────────────────────────────────────────────────────
let isRendering = false;
function renderAll() {
  if (isRendering) return;
  isRendering = true;
  suppressBlur = true; // block stale blur events during DOM rebuild
  Object.keys(nodePos).forEach(k => delete nodePos[k]);
  layoutTree(); buildDOM(); saveState();
  suppressBlur = false;
  isRendering = false;
}

// ─── Pan / Zoom ───────────────────────────────────────────────────────────────
let tx = 100, ty = 80, scale = 1;
let isPanning = false, panStart = null;

function updateTransform() {
  mapContainer.style.transform = `translate(${tx}px,${ty}px) scale(${scale})`;
}

const canvasWrap = document.getElementById('canvas-wrap');
let saveDebounceTimer = null;
function saveDebounced() {
  clearTimeout(saveDebounceTimer);
  saveDebounceTimer = setTimeout(saveState, 300);
}

canvasWrap.addEventListener('wheel', e => {
  e.preventDefault();
  const delta = Math.sign(e.deltaY) * Math.min(Math.abs(e.deltaY), 100);
  const f = 1 - delta * 0.0008;
  const r = canvasWrap.getBoundingClientRect();
  const mx = e.clientX - r.left, my = e.clientY - r.top;
  tx = mx - (mx - tx) * f; ty = my - (my - ty) * f;
  scale = Math.max(0.15, Math.min(4, scale * f));
  updateTransform(); saveDebounced();
}, { passive: false });

canvasWrap.addEventListener('mousedown', e => {
  if (e.target.closest('.node-el')) return;
  isPanning = true;
  panStart = { x: e.clientX - tx, y: e.clientY - ty };
  canvasWrap.style.cursor = 'grabbing';
});
window.addEventListener('mousemove', e => {
  if (!isPanning) return;
  tx = e.clientX - panStart.x; ty = e.clientY - panStart.y; updateTransform();
});
window.addEventListener('mouseup', () => {
  if (isPanning) { isPanning = false; canvasWrap.style.cursor = ''; saveState(); }
});

function zoomIn()    { scale = Math.min(4, scale * 1.2); updateTransform(); saveState(); }
function zoomOut()   { scale = Math.max(0.15, scale / 1.2); updateTransform(); saveState(); }
function resetZoom() {
  const PADDING = 60;
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  Object.values(nodes).forEach(n => {
    const pos = nodePos[n.id]; if (!pos) return;
    const w = measureText(n.label || '');
    minX = Math.min(minX, pos.x);       minY = Math.min(minY, pos.y);
    maxX = Math.max(maxX, pos.x + w);   maxY = Math.max(maxY, pos.y + NODE_H);
  });
  if (minX === Infinity) { tx = 100; ty = 80; scale = 1; updateTransform(); return; }

  const treeW = maxX - minX, treeH = maxY - minY;
  const vw = window.innerWidth, vh = window.innerHeight;
  const fitScale = Math.min(
    (vw - PADDING * 2) / treeW,
    (vh - PADDING - 150) / treeH
  );
  scale = fitScale;
  tx = PADDING - minX * scale;
  ty = PADDING - minY * scale;
  updateTransform();
  saveState();
}

// ─── Persistence ──────────────────────────────────────────────────────────────
const STORAGE_KEY = 'mindmap_v2';
function saveState() {
  if (isUndoRedo) return;
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      nodes: Object.values(nodes).map(n => ({
        id: n.id, label: n.label, children: [...n.children], parentId: n.parentId
      })),
      rootId: root?.id, idCounter, tx, ty, scale
    }));
  } catch(e) {}
}

function loadState() {
  try {
    const data = JSON.parse(localStorage.getItem(STORAGE_KEY));
    if (!data?.nodes?.length) return false;
    data.nodes.forEach(n => { nodes[n.id] = { ...n, children: [] }; });
    data.nodes.forEach(n => {
      if (nodes[n.id]) nodes[n.id].children = n.children.filter(cid => nodes[cid]);
    });
    idCounter = data.idCounter || data.nodes.reduce((m, n) => Math.max(m, n.id), 0);
    const rootNode = nodes[data.rootId];
    if (!rootNode) return false;
    root = rootNode;
    tx = data.tx ?? 100; ty = data.ty ?? 80; scale = data.scale ?? 1;
    return true;
  } catch(e) { return false; }
}

function startOver(e) {
  if (!e.ctrlKey) return;
  pushUndo();
  Object.keys(nodes).forEach(k => delete nodes[k]);
  idCounter = 0; root = createNode(null, '');
  tx = 100; ty = 80; scale = 1;
  updateTransform(); renderAll();
}

const loaded = loadState();
if (!loaded) { root = createNode(null, ''); }
renderAll(); updateTransform();
if (!loaded) { setTimeout(() => startEdit(root.id), 80); }
updateUndoButtons();
</script>

<script>
// ─── Vector SVG export ────────────────────────────────────────────────────────
function buildVectorSVG({ transparent = false } = {}) {
  const colors = getThemeColors();
  const bgColor = colors.bg, textColor = colors.text, phColor = colors.ph;

  const PADDING = 60;
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  Object.values(nodes).forEach(n => {
    const pos = nodePos[n.id]; if (!pos) return;
    const w = measureText(n.label || 'type here…');
    minX = Math.min(minX, pos.x); minY = Math.min(minY, pos.y);
    maxX = Math.max(maxX, pos.x + w); maxY = Math.max(maxY, pos.y + NODE_H);
  });

  const W = maxX - minX + PADDING * 2, H = maxY - minY + PADDING * 2;
  const ox = -minX + PADDING, oy = -minY + PADDING;

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
  svg.setAttribute('width', W); svg.setAttribute('height', H);
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);

  if (!transparent) {
    const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    bgRect.setAttribute('width', '100%'); bgRect.setAttribute('height', '100%');
    bgRect.setAttribute('fill', bgColor); svg.appendChild(bgRect);
  }

  const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  g.setAttribute('transform', `translate(${ox},${oy})`);
  const G = 16, RO = 25;

  Object.values(nodes).forEach(n => {
    if (!n.children.length) return;
    const pPos = nodePos[n.id]; if (!pPos) return;
    const labelW = measureText(n.label);
    const firstPos = nodePos[n.children[0]];
    const lastPos  = nodePos[n.children[n.children.length - 1]];
    if (!firstPos || !lastPos) return;

    const railX = firstPos.x - RO, stubX = pPos.x + labelW + G;
    const pY = pPos.y + NODE_H/2, firstY = firstPos.y + NODE_H/2, lastY = lastPos.y + NODE_H/2;
    const railTop = Math.min(pY, firstY), railBottom = lastY;

    let d;
    if (n.children.length === 1 && firstY === pY) {
      d = `M ${stubX} ${pY} H ${firstPos.x - G}`;
    } else {
      d = `M ${stubX} ${pY} H ${railX} V ${railBottom}`;
      if (railTop < pY) d = `M ${stubX} ${pY} H ${railX} V ${railTop} M ${railX} ${pY} V ${railBottom}`;
    }

    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('stroke', textColor); path.setAttribute('stroke-width', '1');
    path.setAttribute('stroke-linecap', 'square'); path.setAttribute('stroke-linejoin', 'miter');
    path.setAttribute('fill', 'none'); path.setAttribute('d', d);
    g.appendChild(path);

    n.children.forEach(cid => {
      if (n.children.length === 1 && firstY === pY) return;
      const cPos = nodePos[cid]; if (!cPos) return;
      const branch = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      branch.setAttribute('stroke', textColor); branch.setAttribute('stroke-width', '1');
      branch.setAttribute('stroke-linecap', 'square'); branch.setAttribute('fill', 'none');
      branch.setAttribute('d', `M ${railX} ${cPos.y + NODE_H/2} H ${cPos.x - G}`);
      g.appendChild(branch);
    });
  });

  Object.values(nodes).forEach(n => {
    const pos = nodePos[n.id]; if (!pos) return;
    const textEl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    textEl.setAttribute('x', pos.x); textEl.setAttribute('y', pos.y + 15);
    textEl.setAttribute('font-family', 'JetBrains Mono, monospace');
    textEl.setAttribute('font-size', '13'); textEl.setAttribute('font-weight', '400');
    textEl.setAttribute('fill', n.label ? textColor : phColor);
    textEl.setAttribute('letter-spacing', '0.01em');
    textEl.textContent = n.label || (n.parentId == null ? 'type here…' : '…');
    g.appendChild(textEl);
  });

  svg.appendChild(g);
  return { svg, W, H, bgColor };
}

function exportSVG() {
  const { svg } = buildVectorSVG({ transparent: false });
  const name = (root?.label || 'mindmap').replace(/[^a-z0-9_-]/gi, '_').toLowerCase();
  const blob = new Blob([new XMLSerializer().serializeToString(svg)], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = name + '.svg'; a.click();
  URL.revokeObjectURL(url);
}

const RASTER_SCALE = 9;
function setProgress(pct, label) {
  document.getElementById('export-progress-bar').style.width = pct + '%';
  document.getElementById('export-label').textContent = label;
}

async function exportRaster(format) {
  const overlay = document.getElementById('export-overlay');
  overlay.classList.add('visible');
  setProgress(0, `exporting ${format}…`);
  await new Promise(r => setTimeout(r, 60));

  try {
    const isPNG = format === 'png';
    const { svg, W, H, bgColor } = buildVectorSVG({ transparent: isPNG });
    setProgress(15, 'loading font…');
    await new Promise(r => setTimeout(r, 30));

    let fontFace = '';
    try {
      const fontResp = await fetch(
        'https://fonts.gstatic.com/s/jetbrainsmono/v18/tDbY2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKxTOlOTk6OThhvAWV8.woff2'
      );
      if (fontResp.ok) {
        const buf = await fontResp.arrayBuffer();
        const bytes = new Uint8Array(buf);
        let binary = '';
        for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
        fontFace = `<defs><style>@font-face{font-family:'JetBrains Mono';font-weight:400;src:url('data:font/woff2;base64,${btoa(binary)}') format('woff2');}</style></defs>`;
      }
    } catch(_) {}

    setProgress(35, 'rendering svg…');
    await new Promise(r => setTimeout(r, 30));

    let svgStr = new XMLSerializer().serializeToString(svg);
    if (fontFace) svgStr = svgStr.replace(/<svg([^>]*)>/, `<svg$1>${fontFace}`);

    const svgBlob = new Blob([svgStr], { type: 'image/svg+xml;charset=utf-8' });
    const svgUrl  = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgStr);

    setProgress(55, 'drawing canvas…');
    const img = new Image();
    img.width  = W * RASTER_SCALE;
    img.height = H * RASTER_SCALE;
    await new Promise((res, rej) => { img.onload = res; img.onerror = rej; img.src = svgUrl; });

    const canvas = document.createElement('canvas');
    canvas.width  = W * RASTER_SCALE; canvas.height = H * RASTER_SCALE;
    const ctx = canvas.getContext('2d');

    setProgress(75, 'compositing…');
    await new Promise(r => setTimeout(r, 30));

    ctx.fillStyle = bgColor;
    if (!isPNG) ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    setProgress(90, 'encoding…');
    await new Promise(r => setTimeout(r, 30));

    const name = (root?.label || 'mindmap').replace(/[^a-z0-9_-]/gi, '_').toLowerCase();
    const mimeType = isPNG ? 'image/png' : 'image/jpeg';
    const quality  = isPNG ? undefined : 0.95;

    const fileBlob = await new Promise(res => canvas.toBlob(res, mimeType, quality));
    const fileUrl  = URL.createObjectURL(fileBlob);
    const a = document.createElement('a');
    a.href = fileUrl; a.download = `${name}.${format}`; a.click();
    setTimeout(() => URL.revokeObjectURL(fileUrl), 1000);

    setProgress(100, 'done ✓');
    await new Promise(r => setTimeout(r, 500));
  } catch(err) {
    console.error('Export error:', err);
    setProgress(0, 'error ✗');
    await new Promise(r => setTimeout(r, 1000));
  } finally {
    overlay.classList.remove('visible');
    setProgress(0, '');
  }
}
</script>
</body>
</html>
